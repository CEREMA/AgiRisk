# -*- coding: utf-8 -*-
"""
/***************************************************************************
 AgiRisk
                                 A QGIS plugin
 Plugin du projet AgiRisk
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2022-04-06
        git sha              : $Format:%H$
        copyright            : (C) 2023 by Cerema
        email                : agirisk@cerema.fr
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

from posixpath import basename
import os, sys, webbrowser

from qgis.core import QgsMessageLog, Qgis, QgsVectorLayer, QgsProject, QgsCoordinateReferenceSystem, QgsField, QgsRectangle, QgsSettings, QgsFields, QgsFeature, QgsLayerTreeGroup
from qgis.PyQt import uic

from qgis.utils import iface

from PyQt5.QtWidgets import QMessageBox, QFileDialog, QInputDialog, QVBoxLayout, QLineEdit, QDialog, QTextEdit
from PyQt5 import QtWidgets
from PyQt5.QtCore import QVariant, Qt

from .classes.Bdd import Bdd
from .classes.ModeleTerritorial import ModeleTerritorial
from .classes.Ressources import Ressources, chgt_classe_zoom
from .classes.ArborescenceActions import ArborescenceActions

from .classes.messages_utilisateur import avertissement

from functools import partial


# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
# FORM_CLASS, _ = uic.loadUiType(os.path.join(
#     os.path.dirname(__file__), 'agirisk_dialog_base.ui'))

sys.path.append(os.path.dirname(__file__))
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'agirisk_dialog_base.ui'), resource_suffix='')


class AGIRISKDialog(QtWidgets.QDialog, FORM_CLASS):
    def __init__(self, parent=None):
        """Constructor."""
        super(AGIRISKDialog, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        self.setupUi(self) # TODO : optimiser le temps de chargement
        self.setWindowFlag(Qt.MSWindowsFixedSizeDialogHint)
        self.setWindowFlag(Qt.BypassWindowManagerHint) if 'win' in sys.platform.lower() else None
        self.setWindowFlag(Qt.WindowMinimizeButtonHint, True)

        # Chargement des images
        self.label_21.setStyleSheet("background-color: rgba(255, 255, 255, 0); background-image: url(:/plugins/plugin_agirisk/medias/PhotoCrueNemoursArnaudBouissouTerra.png)")
        self.widget_7.setStyleSheet("image: url(:/plugins/plugin_agirisk/medias/territoiresfr.png);")
        self.widget_6.setStyleSheet("image: url(:/plugins/plugin_agirisk/medias/personnalisation.png);")
        self.widget_5.setStyleSheet("image: url(:/plugins/plugin_agirisk/medias/analyse.png);")
        self.widget_11.setStyleSheet("image: url(:/plugins/plugin_agirisk/medias/action.gif);")
        self.widget_4.setStyleSheet("image: url(:/plugins/plugin_agirisk/medias/suivi.gif);")
        self.pb_lien_site_agirisk.setStyleSheet("image: url(:/plugins/plugin_agirisk/medias/Logo AgiRisk.png);\nbackground-color: rgb(255, 255, 255);")
        self.pb_lien_site_agirisk_2.setStyleSheet("image: url(:/plugins/plugin_agirisk/medias/Logo AgiRisk.png);\nbackground-color: rgb(255, 255, 255);\nborder:none;")
        self.widget_12.setStyleSheet("image: url(:/plugins/plugin_agirisk/medias/Exemple_graphique_avancement_actions.gif);")

        # Initialisation des ressources
        self.ressources = Ressources(self)

        # Création du répertoire paramètres_locaux s'il n'existe pas
        if not os.path.exists(os.path.join(os.path.dirname(__file__), 'parametres_locaux')):
            os.makedirs(os.path.join(os.path.dirname(__file__), 'parametres_locaux'))

        self.bdd = Bdd(self, "../parametres_locaux/credentials_bdd.json")
        if not self.bdd.successful_init:
            return
        else:
            self.ressources.get_niv_zoom()
            self.liste_rep_carto_dispos_en_base = self.bdd.liste_indicateurs() # Nécessaire pour initialiser correctement l'arborescence des indicateurs
            self.liste_rep_carto_dispos_en_base_par_terr = {}
            self.canvas = iface.mapCanvas()

            # La première étape consiste à choisir un territoire d'étude
            self.etape_avancement = "choix_territoire"
            self.modeles_terr = {} # Dictionnaire des modèles territoriaux (1 modèle par territoire d'étude)
            self.arbo_actions = ArborescenceActions(self)

            # Initialisation des conteneurs d'objets / widgets liés à l'interface
            self.indicateurs = {} # Onglet modalités de calcul - Contient les widgets (QCheckBox)
            self.fonctions = {} # Onglet modalités de calcul - Contient les widgets (QCheckBox)
            self.pts_vue = {} # Onglet indicateurs - Contient les widgets (boutons radio) points de vue
            self.layer_tree = {} # Interface QGis - Contient le node (layerTreeGroup) correspondant aux territoires chargés (clé = territoire, valeur = node)

            # Initialisation des variables de travail
            self.echelle_prec = 2000000
            self.pt_vue_actif = ""
            self.terr_actif = ""
            self.modele_terr_est_defini = False


            # Finalisation de l'interface graphique
            self.finalisation_interface()

            # Connexions slots et signaux
            self.init_signals()

        # Initialisation des variables QGIS.ini
        self.QGISIniSave()

        QgsMessageLog.logMessage("Plugin AgiRisk initialisé", "AgiRisk", level = Qgis.Info) # QGis.Debug / QGis.Info  / QGis.Warning / QGis.Error / QGis.Critical

        # TODO V2
        self.slider_temporel.setVisible(False)
        self.mode_expert.setVisible(False)


    def closeEvent(self, event):
        ''' TODO : décommenter en s'assurant que la fenêtre principale est bien supprimée'''
        # Déconnexion des signaux
        self.terminate_signals()

        # Suppression des variables
        # del self.ressources
        # del self.bdd
        # del self.modeles_terr
        # del self.arbo_actions
        # del self.indicateurs
        # del self.fonctions
        # del self.pts_vue
        # del self.layer_tree
        # del self.terr_actif

        super(AGIRISKDialog, self).closeEvent(event)


    ##########################################################################################################
    # Section Initilisations
    ##########################################################################################################
    def entrer_infos_connexion(self, hostname, port, bdd, login, pwd):
        # Création d'une boîte de dialogue "container"
        container = QtWidgets.QInputDialog()
        container.setWindowTitle("Connexion à la base de données en erreur")
        container.setLabelText(None)
        container.setFixedSize(320,240)
        container.show()
        container.findChild(QLineEdit).hide()    # On cache la QLineEdit par défaut

        # Ajout d'un label, d'une liste déroulante du territoire, d'un label et d'une liste déroulante des types d'aléas
        label_server = QtWidgets.QLabel("Serveur (IP ou nom)")
        input_server = QLineEdit(hostname)
        label_port = QtWidgets.QLabel("Port")
        input_port = QLineEdit(port)
        label_bdd = QtWidgets.QLabel("Base de données")
        input_bdd = QLineEdit(bdd)
        label_user = QtWidgets.QLabel("Utilisateur")
        input_user = QLineEdit(login)
        label_pwd = QtWidgets.QLabel("Mot de passe")
        input_pwd = QLineEdit(pwd)
        input_pwd.setEchoMode(QLineEdit.PasswordEchoOnEdit)

        # Ajout des widgets dans le container
        container.layout().insertWidget(1, label_server)
        container.layout().insertWidget(2, input_server)
        container.layout().insertWidget(3, label_port)
        container.layout().insertWidget(4, input_port)
        container.layout().insertWidget(5, label_bdd)
        container.layout().insertWidget(6, input_bdd)
        container.layout().insertWidget(7, label_user)
        container.layout().insertWidget(8, input_user)
        container.layout().insertWidget(9, label_pwd)
        container.layout().insertWidget(10, input_pwd)

        ret = container.exec_()

        return input_server.text(), input_port.text(), input_bdd.text(), input_user.text(), input_pwd.text(), ret


    def finalisation_interface(self):
        '''Cette méthode permet de finaliser l'interface en fonction des paramètres de configuration.
        Elle se limite cependant à l'initialisation complémentaires des seuls widgets ne dépendant pas des choix ultérieurs de l'utilisateur.
        Ainsi, les composants suivants ne sont pas initialisés à ce stade :
            - partie basse de l'onglet indicateurs (arborescence)
            - onglet dashboard
            - onglet actions
        '''
        self.codes_onglets = {"accueil": 0, "terr_etude": 1, "choix_indic": 2, "moda_calcul": 3, "diagnostic": 4, "actions_reduc": 5, "suivi_actions": 6, "aide": 7}
        self.bts_onglets = {"accueil": self.menu_accueil,
                            "terr_etude": self.menu_terr_etude,
                            "choix_indic": self.menu_choix_indic,
                            "moda_calcul": self.menu_moda_calcul,
                            "diagnostic": self.menu_diag,
                            "actions_reduc": self.menu_actions_reduc,
                            "suivi_actions": self.menu_suivi_actions,
                            "aide": self.menu_aide}
        self.affiche_page("accueil")
        # On désactive les onglets Personnalisation / Diagnostic / Actions / Suivi des actions tant qu'un territoire n'est pas sélectionné
        self.etape_avancement = "choix_territoire"
        self.maj_etape_avancement()

        # On purge le gestionnaire des couches d'éventuels groupes issus d'une utilisation précédente du plugin
        # Cette opération est sans effet sur les couches tierces non issues d'une précédente utilisation du plugin
        root = QgsProject.instance().layerTreeRoot()
        children = root.children()
        for child in children:
            if child.name().split(' - ')[0] == 'AgiRisk':
                child.parent().takeChild(child)

        # Par défaut le mode expert est désactivé
        self.mode_exp = False
        self.modif_mode_expert()

        # Initialisation de l'onglet territoires
        liste_territoires = self.bdd.recup_donnees(['id', 'territoire'], 'c_general.territoires', where="", tri='territoire')
        for terr in liste_territoires:
            self.cbox_terr_etude.addItem(terr['territoire'])
        # Chargement d'une vue France Métropolitaine par défaut
        self.load_layer_in_minimap([self.ressources.basemaps['osm']], QgsRectangle(54676, 7145758, 1300000, 6000000))

        # Initialisation de la partie générique de l'onglet indicateurs (ajoute un widget bouton radio pour chaque point de vue trouvé)
        for pt_vue in self.ressources.liste_pts_vue:
            self.pts_vue[pt_vue] = {}
            self.pts_vue[pt_vue]['w_arborescence'] = QtWidgets.QRadioButton(self.rb_parent_pt_vue)
            self.pts_vue[pt_vue]['w_arborescence'].setObjectName(pt_vue)
            self.pts_vue[pt_vue]['w_arborescence'].setVisible(True)
            self.pts_vue[pt_vue]['w_arborescence'].setText(pt_vue)
            self.layout_liste_pts_vue.addWidget(self.pts_vue[pt_vue]['w_arborescence'])

        # Initialisation du conteneur des arborescences indicateurs
        self.layout_arborescences = QVBoxLayout(self.widget_14)
        self.layout_arborescences.setSpacing(0)
        self.layout_arborescences.setContentsMargins(0,0,0,0)

        # On choisit par défaut le point de vue 'SNGRI'
        self.pt_vue_actif = "SNGRI"
        self.pts_vue[self.pt_vue_actif]['w_arborescence'].setChecked(True)

        # Changement des couleurs des boutons de lancement des calculs (var, indicateurs, représentation cartographiques)
        self.pb_var_all.setStyleSheet(self.ressources.css_bt_calcul_indic['non_lance'])

        # Initialisation de l'onglet modalités de calcul
        self.init_rep_carto_dispos_en_base()
        # self.init_indicateurs_json()
        self.init_fonctions_calcul()

        # Puis on remplit les comboBox des millésimes avec les valeurs trouvées en base
        self.millesimes = self.bdd.recup_millesimes()
        self.millesimes['gpu']['widget'] = self.cb_millesime_gpu
        self.millesimes['bdtopo']['widget'] = self.cb_millesime_bdtopo
        self.millesimes['rpg']['widget'] = self.cb_millesime_rpg
        self.millesimes['adresse']['widget'] = self.cb_millesime_adresse
        self.millesimes['insee']['widget'] = self.cb_millesime_insee
        self.millesimes['inao']['widget'] = self.cb_millesime_inao
        self.millesimes['sirene']['widget'] = self.cb_millesime_sirene

        for couche in self.millesimes.keys():
            # On purge la liste des millésimes du widget
            self.millesimes[couche]['widget'].clear()
            for mill in self.millesimes[couche]['dispos']:
                self.millesimes[couche]['widget'].addItem(str(mill))
            # On sélectionne le millésime par défaut
            index_plus_recent = self.millesimes[couche]['widget'].findText(str(self.millesimes[couche]['plus_recent']))
            if index_plus_recent >= 0:
                self.millesimes[couche]['widget'].setCurrentIndex(index_plus_recent)

        # Initialisation des niveaux de synthèse dans l'onglet dashboard
        self.cbox_niv_synthese.clear()
        for niv, ech in self.ressources.niv_synthese.items():
            self.cbox_niv_synthese.addItem(ech)
        self.cbox_niv_synthese.setCurrentIndex(-1)
        # self.echelle = self.ressources.niv_synthese[0]
        self.echelle = self.ressources.niv_zoom_code["IRIS"] # Correspond au niveau de zoom "Iris"

        '''
        La section qui suit est provisoire à la version 1.0
        '''
        # Désactivation du bouton lié au cochage des thématiques
        self.pb_valider_thematiques.setVisible(False)
        # Désactivation du cadre de sélection des thématiques et centres d'intérêt
        self.gb_thematiques.setVisible(False)
        # Désactivation du bouton de personnalisation d'une nouvelle arborescence
        self.pb_nvelle_arborescence.setVisible(False)
        # Simplification de l'interface de l'onglet diagnostic
        self.gb_mise_en_forme_resultats.setVisible(False)
        self.gb_mise_en_forme_resultats_2.setVisible(False)


    def init_rep_carto_dispos_en_base(self):
        '''Cette fonction permet de finaliser l'initialisation de l'onglet modalités de calcul en récupérant les noms des tables indicateurs disponibles
        dans la base demo_agirisk'''

        for i, indic in enumerate(self.liste_rep_carto_dispos_en_base):
            code_indic = indic
            self.indicateurs[code_indic] = {}
            self.indicateurs[code_indic]['widget_base'] = QtWidgets.QCheckBox(self.w_listing_indicateurs)
            self.indicateurs[code_indic]['widget_base'].setObjectName(code_indic)
            self.indicateurs[code_indic]['widget_base'].setVisible(True)
            self.indicateurs[code_indic]['widget_base'].setText(code_indic)
            self.lay_listing_indicateurs.addWidget(self.indicateurs[code_indic]['widget_base'])


    def init_indicateurs_json(self):
        '''Cette fonction permet de finaliser l'initialisation de l'onglet modalités de calcul en récupérant les noms des indicateurs disponibles
        dans le point de vue sélectionné par l'utilisateur
        '''

        indicateurs_retenus = self.modele_terr_actif.arbo_indicateurs.liste_indicateurs()
        liste_fonctions_base = self.bdd.liste_fonctions()
        liste_fonctions_var_indic = liste_fonctions_base['var'] + liste_fonctions_base['indic']
        for indic in indicateurs_retenus:
            code_indic = indic['code']
            if code_indic not in self.indicateurs:
                self.indicateurs[code_indic] = {}
            self.indicateurs[code_indic]['widget_json'] = QtWidgets.QCheckBox(self.w_listing_indicateurs_pt_vue)
            self.indicateurs[code_indic]['widget_json'].setObjectName(code_indic)
            self.indicateurs[code_indic]['widget_json'].setVisible(True)
            self.indicateurs[code_indic]['widget_json'].setText(f"{code_indic} ({', '.join(var['code_variable'] for var in indic['moda_calcul']['dependances_variables']) if 'moda_calcul' in indic.keys() else ''})")
            self.indicateurs[code_indic]['widget_json'].setToolTip(indic['nom_reformule'] if "nom_reformule" in indic.keys() else "")
            # Lorsque la fonction correspondant à l'indicateur est disponible en base, on change la couleur d'affichage du widget en noir, sinon en gris clair
            if code_indic.replace("/", "_").lower() in liste_fonctions_var_indic:
                self.indicateurs[code_indic]['widget_json'].setStyleSheet("color: black")
                self.indicateurs[code_indic]['widget_json'].setEnabled(True)
            else:
                self.indicateurs[code_indic]['widget_json'].setStyleSheet("color: lightgray")
                self.indicateurs[code_indic]['widget_json'].setEnabled(False)
            self.lay_listing_indicateurs_pt_vue.addWidget(self.indicateurs[code_indic]['widget_json'])


    def init_fonctions_calcul(self):
        '''Cette fonction permet de finaliser l'initialisation de l'onglet modalités de calcul en récupérant les noms des fonctions de calcul
        (variables et indicateurs) disponibles dans la base demo_agirisk'''
        liste_fonctions = self.bdd.liste_fonctions()

        for fonc in liste_fonctions["var"] + liste_fonctions["indic"]:
            code_fonc = str(fonc)
            self.fonctions[code_fonc] = {}
            self.fonctions[code_fonc]['widget'] = QtWidgets.QCheckBox(self.w_listing_fonctions_calcul)
            self.fonctions[code_fonc]['widget'].setObjectName(code_fonc)
            self.fonctions[code_fonc]['widget'].setVisible(True)
            self.fonctions[code_fonc]['widget'].setText(code_fonc)
            self.lay_listing_fonctions_calcul.addWidget(self.fonctions[code_fonc]['widget'])


    def  QGISIniSave(self):

        #Mise à jour du fichier de configuration de la base PG (param_serveur.csv)
        mDicParam = {}
        mSettings = QgsSettings()
        mSettings.beginGroup("Plugin_AgiRisk")
        mDicParam["AdrServPG"] = 'localhost'
        '''
        mDicParam["port"] = self.linePortServ.text()
        mDicParam["user"] = self.lineUserServ.text()
        mDicParam["mdp"] = self.lineMdpServ.text()
        mDicParam["NomBD"] = self.lineBaseDonnees.text()
        mDicParam["schemaData"] = self.comboBoxChoixSchemaData.currentText()
        mDicParam["schemaBDTopo"] = self.comboBoxChoixSchemaBDTopo.currentText()
        mDicParam["schemaFFDep"] = self.comboBoxChoixSchemaFFDep.currentText()
        mDicParam["schemaProd"] = self.comboBoxChoixSchemaProd.currentText()
        mDicParam["TabPlu"] = self.comboBoxChoixTabPlu.currentText()
        mDicParam["TabEnvurb"] = self.comboBoxChoixTabEnvurb.currentText()
        mDicParam["TabOcsge"] = self.comboBoxChoixTabOcsge.currentText()
        mDicParam["TabCommune"] = self.comboBoxChoixTabCommune.currentText()
        mDicParam["TabBati"] = self.comboBoxChoixTabBati.currentText()
        mDicParam["TabRoute"] = self.comboBoxChoixTabRoute.currentText()
        mDicParam["TabTup"] = self.comboBoxChoixTabTup.currentText()
        '''
        for key, value in mDicParam.items():
           mSettings.setValue(key, value)
        mSettings.endGroup()


    def affichage_fenetre(self, event):
        if self.modele_terr_est_defini:
            self.canvas.scaleChanged.connect(self.maj_zoom)


    def init_signals(self):
        ##########################################################################################################
        # Section Interface QGis
        ##########################################################################################################
        # self.canvas.scaleChanged.connect(self.maj_zoom) # Doit être connecté uniquement lorsque le territoire est défini

        # Lorsque la fenêtre du plugin devient visible, on lance la méthode self.affichage_fenetre
        self.showEvent = self.affichage_fenetre


        ##########################################################################################################
        # Section Page d'accueil et Menu
        ##########################################################################################################
        self.menu_accueil.clicked.connect(partial(self.affiche_page, "accueil"))

        self.accueil_terr_etude.clicked.connect(partial(self.affiche_page, "terr_etude"))
        self.menu_terr_etude.clicked.connect(partial(self.affiche_page, "terr_etude"))

        self.menu_choix_indic.clicked.connect(partial(self.affiche_page, "choix_indic"))
        self.accueil_choix_indic.clicked.connect(partial(self.affiche_page, "choix_indic"))

        self.menu_moda_calcul.clicked.connect(partial(self.affiche_page, "moda_calcul"))

        self.menu_diag.clicked.connect(partial(self.affiche_page, "diagnostic"))
        self.menu_diag.clicked.connect(self.charger_diagnostic)
        self.accueil_diag.clicked.connect(partial(self.affiche_page, "diagnostic"))
        self.accueil_diag.clicked.connect(self.charger_diagnostic)

        self.menu_actions_reduc.clicked.connect(partial(self.affiche_page, "actions_reduc"))
        self.menu_actions_reduc.clicked.connect(self.charger_onglet_actions)
        self.accueil_actions_reduc.clicked.connect(partial(self.affiche_page, "actions_reduc"))
        self.accueil_actions_reduc.clicked.connect(self.charger_onglet_actions)

        self.menu_suivi_actions.clicked.connect(partial(self.affiche_page, "suivi_actions"))
        self.accueil_suivi_actions.clicked.connect(partial(self.affiche_page, "suivi_actions"))

        self.menu_aide.clicked.connect(partial(self.affiche_page, "aide"))

        self.mode_expert.stateChanged.connect(self.modif_mode_expert)

        self.pb_lien_site_agirisk.clicked.connect(self.ouvrir_lien_site_agirisk)
        self.pb_lien_site_agirisk_2.clicked.connect(self.ouvrir_lien_site_agirisk)

        self.pb_lien_mail.clicked.connect(self.ouvrir_lien_mail)

        self.pb_lien_site_cerema.clicked.connect(self.ouvrir_lien_site_cerema)

        ##########################################################################################################
        # Section Territoire d'étude
        ##########################################################################################################
        self.selection_territoire_etude.clicked.connect(self.chargement_nouveau_territoire)
        self.cbox_terr_etude.currentIndexChanged.connect(self.choix_territoire)

        self.selection_alea.clicked.connect(self.chargement_nouvel_alea)
        self.cbox_couche_alea.currentIndexChanged.connect(self.choix_couche_alea)
        self.cbox_type_alea.currentIndexChanged.connect(self.choix_type_alea)

        ##########################################################################################################
        # Section Choix des indicateurs
        ##########################################################################################################
        for pt_vue in self.ressources.liste_pts_vue:
            self.pts_vue[pt_vue]['w_arborescence'].toggled.connect(self.changer_pt_vue)
        
        self.pb_var_all.clicked.connect(self.lancer_calculs)

        ##########################################################################################################
        # Section Modalités de calcul
        ##########################################################################################################
        self.pb_charger_couches_indicateurs.clicked.connect(self.charger_indicateurs_selectionnes)
        self.pb_calcul_expert.clicked.connect(self.calcul_expert)

        for couche in self.millesimes.keys():
            self.millesimes[couche]['widget'].currentIndexChanged.connect(self.maj_millesime)


        ##########################################################################################################
        # Section Diagnostic
        ##########################################################################################################
        self.pb_calcul_indic.clicked.connect(self.charger_diagnostic)
        self.cbox_niv_synthese.currentIndexChanged.connect(self.maj_echelle_synthese)
        self.cbox_secteur_etude.currentIndexChanged.connect(self.maj_secteur_etude)

        ##########################################################################################################
        # Section Actions de réduction de vulnérabilité
        ##########################################################################################################

        ##########################################################################################################
        # Section Suivi des actions
        ##########################################################################################################

        ##########################################################################################################
        # Section Aide
        ##########################################################################################################


    def terminate_signals(self):
        ''' TODO : Reprendre intégralement cette méthode pour prendre en compte les partial() et s'assurer que la
        boîte de dialogue est bien supprimée de la mémoire'''
        ##########################################################################################################
        # Section Interface QGis
        ##########################################################################################################
        try:
            self.canvas.scaleChanged.disconnect(self.maj_zoom)
        except:
            pass


    ##########################################################################################################
    # Section Menu / Navigation
    ##########################################################################################################
    def affiche_cache_menu(self, page_accueil):
        if page_accueil:
            self.top_menu.setVisible(False)
        else:
            self.top_menu.setVisible(True)


    def maj_etape_avancement(self, btn = None):
        # Territoire non sélectionné --> seul onglets territoire / aide activés
        # Territoire et aléas / occurence sélectionnée --> onglets territoires / indicateurs / diagnostic / aide activés
        # Territoire sélectionné et aléa / occurrence non sélectionné --> comme si territoire non sélectionné

        boutons_etape = {"choix_territoire": {"actifs": [self.menu_terr_etude, self.accueil_terr_etude,
                                                        self.menu_aide],
                                                "inactifs": [self.menu_choix_indic,
                                                            self.menu_moda_calcul,
                                                            self.menu_diag,
                                                            self.menu_actions_reduc,
                                                            self.menu_suivi_actions],
                                                "pseudo-inactifs": [self.accueil_choix_indic, self.accueil_diag, self.accueil_suivi_actions, self.accueil_actions_reduc]},
                            "choix_indicateurs": {"actifs": [self.menu_terr_etude, self.accueil_terr_etude,
                                                            self.menu_choix_indic, self.accueil_choix_indic,
                                                            self.menu_aide],
                                                "inactifs": [self.menu_moda_calcul,
                                                            self.menu_diag,
                                                            self.menu_actions_reduc,
                                                            self.menu_suivi_actions],
                                                "pseudo-inactifs": [self.accueil_diag, self.accueil_actions_reduc, self.accueil_suivi_actions]},
                            "diagnostic": {"actifs": [self.menu_terr_etude, self.accueil_terr_etude,
                                                    self.menu_choix_indic, self.accueil_choix_indic,
                                                    self.menu_moda_calcul,
                                                    self.menu_diag,self.accueil_diag,
                                                    self.menu_aide],
                                                "inactifs": [self.menu_actions_reduc, self.menu_suivi_actions],
                                                "pseudo-inactifs": [self.accueil_actions_reduc, self.accueil_suivi_actions]},
                            "choix_actions": {"actifs": [self.menu_terr_etude, self.accueil_terr_etude,
                                                    self.menu_choix_indic, self.accueil_choix_indic,
                                                    self.menu_moda_calcul,
                                                    self.menu_diag,self.accueil_diag,
                                                    self.menu_actions_reduc, self.accueil_actions_reduc,
                                                    self.menu_aide],
                                                "inactifs": [self.menu_suivi_actions],
                                                "pseudo-inactifs": [self.accueil_suivi_actions]},
                            "suivi_actions": {"actifs": [self.menu_terr_etude, self.accueil_terr_etude,
                                                        self.menu_choix_indic, self.accueil_choix_indic,
                                                        self.menu_moda_calcul,
                                                        self.menu_diag,self.accueil_diag,
                                                        self.menu_actions_reduc, self.accueil_actions_reduc,
                                                        self.menu_suivi_actions, self.accueil_suivi_actions,
                                                        self.menu_aide],
                                                "inactifs": [],
                                                "pseudo-inactifs": []}}

        if self.etape_avancement in boutons_etape.keys():
            for bouton in boutons_etape[self.etape_avancement]["actifs"]:
                bouton.setEnabled(True)
                bouton.setStyleSheet(self.ressources.get("css_btn_actif")) if (btn == None or btn != bouton) else bouton.setStyleSheet(self.ressources.get("css_btn_courant"))
            for bouton in boutons_etape[self.etape_avancement]["inactifs"]:
                bouton.setEnabled(False)
                bouton.setStyleSheet(self.ressources.get("css_btn_inactif"))
            for bouton in boutons_etape[self.etape_avancement]["pseudo-inactifs"]:
                bouton.setEnabled(False)
                bouton.setStyleSheet(self.ressources.get("css_btn_actif"))


    def affiche_page(self, code):
        self.affiche_cache_menu(code == "accueil")
        if code in self.codes_onglets.keys():
            self.onglets.setCurrentIndex(self.codes_onglets[code])

        if code == "moda_calcul":
            self.maj_millesime()


        for code_btn, onglet in self.bts_onglets.items():
            # Modification de la couleur des boutons de la barre de menu pour indiquer l'onglet actif ( rgb(41,37,116) lorsque inactif, rgb(0,0,0) lorsque actif
            if code == code_btn:
                self.maj_etape_avancement(onglet)


    def modif_mode_expert(self):
        self.mode_exp = self.mode_expert.isChecked()
        if self.mode_exp:
            self.menu_moda_calcul.setVisible(True)
        else:
            self.menu_moda_calcul.setVisible(False)
            if self.onglets.currentIndex() == self.codes_onglets["moda_calcul"]:
                self.onglets.setCurrentIndex(self.codes_onglets["accueil"])


    def ouvrir_lien_site_agirisk(self):
        webbrowser.open('https://agirisk.cerema.fr/')


    def ouvrir_lien_site_cerema(self):
        webbrowser.open('https://www.cerema.fr/fr/activites/environnement-risques/risques-naturels/risques-inondations-submersion')


    def ouvrir_lien_mail(self):
        webbrowser.open('mailto:agirisk@cerema.fr')


    ##########################################################################################################
    # Section Territoire d'étude
    ##########################################################################################################
    def chargement_nouveau_territoire(self):
        '''
            Chargement d'un fichier local comme territoire d'étude à ajouter dans c_general.territoires

            TODO : Catcher les problèmes d'import (je ne sais pas comment faire car ne renvoient pas d'exception)
            TODO : Rajouter un contrôle supplémentaire sur la géométrie rentrée (qui doit être strictement différente des géométries présentes en base)
        '''

        # Sélection du territoire d'études par une boite de dialogue
        file_dialog = QFileDialog()
        file_dialog.setFileMode(QFileDialog.ExistingFile)
        geographic_extensions = self.ressources.get('geographic_extension')
        file, _ = file_dialog.getOpenFileName(self, "Sélectionner un fichier géographique","", f"Fichiers géographiques ({geographic_extensions})")
        if file:    # ne fait rien si aucun fichier choisi
            filename = basename(file).split('.')[0]
            vlayer = QgsVectorLayer(file, filename, "ogr")

            if not vlayer.isValid():
                QMessageBox.critical(self,"Erreur", f"Le fichier {filename} n'est pas un fichier géographique standard.")
                return None
            else:
                # Définition d'une version provisoire du territoire d'étude (en mémoire, non stockée en base)
                if filename not in self.modeles_terr.keys():
                    self.modele_terr_actif = ModeleTerritorial(self, filename, vlayer, provisoire=True)
                else:
                    QgsMessageLog.logMessage(f"Le territoire d'étude {filename} existe déjà dans la liste des territoires d'étude.", "AgiRisk", Qgis.Warning)
                # Affichage du layer dans la minimap
                self.load_layer_in_minimap([self.modele_terr_actif.couche_terr, self.ressources.basemaps['osm']])

                # Choix du nom du territoire par l'utilisateur (en contrôlant que le nom rentré n'existe pas déjà en base)
                liste_noms_territoires_etudes = [ter['territoire'] for ter in self.bdd.recup_donnees(['territoire'], 'c_general.territoires')]
                nom_territoire = ""
                while nom_territoire == "":
                    nom_territoire, ok = QInputDialog.getText(self, f"Import du territoire - {str([str(feat.attributes()) for feat in self.modele_terr_actif.couche_terr.getFeatures()])}", "Nom du territoire")
                    if ok:
                        if nom_territoire == "":
                            avertissement("Veuillez renseigner un nom de territoire avant de cliquer sur OK.", "")
                        elif nom_territoire not in liste_noms_territoires_etudes:

                            # self.modele_terr_actif.def_terr_etude(nom_territoire, vlayer)    # on redéfinit le territoire d'étude avec le nouveau nom
                            if nom_territoire not in self.modeles_terr.keys():
                                self.modeles_terr[nom_territoire] = ModeleTerritorial(self, nom_territoire, vlayer)
                            else:
                                QgsMessageLog.logMessage(f"Le territoire d'étude {nom_territoire} existe déjà dans la liste des territoires d'étude.", "AgiRisk", Qgis.Warning)

                            # On supprime le territoire d'étude temporaire
                            del self.modele_terr_actif

                            # Puis on crée le territoire d'étude en base
                            self.modele_terr_actif = self.modeles_terr[nom_territoire]
                            self.modele_terr_actif.save_terr_etude()

                            # Ajout du territoire dans la liste déroulante
                            self.cbox_terr_etude.addItem(nom_territoire)
                            self.cbox_terr_etude.setCurrentIndex(self.cbox_terr_etude.count() - 1) # sélectionne le dernier élément ajouté

                            # Mise à jour de l'interface graphique pour désactiver les boutons indicateurs / diagnostic / actions
                            self.etape_avancement = "choix_territoire"
                            self.maj_etape_avancement()
                            self.affiche_page("terr_etude")
                            self.maj_statut_calculs_en_base()
                        else:
                            avertissement(f"Il semblerait que le territoire '{self.modele_terr_actif.terr }' existe déjà en base de données.","Si vous êtes certain que ce territoire n'existe pas dans la base, renommez-le. Sinon, choisissez un autre territoire.")

                    else:
                        break


    def chargement_nouvel_alea(self):
        '''
        Lorsque l'utilisateur charge une nouvelle couche géographique :
        Vérification qu'il s'agit d'une couche polygone / multipolygone,
        Vérification que la structure des champs est conforme à Zx,
        Tracé de l'emprise de la zone inondable dans l'emprise carto,
        Demande confirmation utilisateur (dialogue pop up) de valider cette couche,
        Upload des données par un appel à self.modele_terr_actif,
        Mise à jour de la QComboBox et de self.etat_plugin,
        Chargement dans le contrôle des couches d'une couche temporaire "Aléa"
        '''

        file_dialog = QFileDialog()
        file_dialog.setFileMode(QFileDialog.ExistingFile)
        geographic_extensions = self.ressources.get('geographic_extension')
        file, _ = file_dialog.getOpenFileName(self, "Sélectionner un fichier géographique","", f"Fichiers géographiques ({geographic_extensions})")
        if file:    # ne fait rien si aucun fichier choisi
            filename = basename(file).split('.')[0]
            reallayer = QgsVectorLayer(file, filename, "ogr")
            if not reallayer.isValid():
                QMessageBox.critical(self,"Erreur", f"Le fichier {filename} n'est pas un fichier géographique standard.")
                return None
            else:
                # Récupération des territoires distincts depuis la bdd
                dict_terr = self.bdd.recup_donnees(['territoire'], 'c_general.territoires', unique='territoire')
                list_terr = sorted([res['territoire'] for res in dict_terr])

                # Récupération des aléas distincts depuis la bdd
                dict_type_aleas = self.bdd.recup_donnees(['type_alea'], 'c_phenomenes.zq', unique='type_alea')
                list_type_aleas = sorted([res['type_alea'] for res in dict_type_aleas])

                # Récupération des occurences distincts depuis la bdd
                dict_occ = self.bdd.recup_donnees(['occurrence'], 'c_phenomenes.zq', where="occurrence is not NULL", unique='occurrence')
                list_occ = sorted([str(res['occurrence']) for res in dict_occ])

                # Récupération des codes occurence distincts depuis la bdd
                dict_code_occ = self.bdd.recup_donnees(['code_occurrence'], 'c_phenomenes.zq', unique='code_occurrence')
                list_code_occ = sorted([res['code_occurrence'] for res in dict_code_occ])

                # Récupération des descriptions d'aléas distincts depuis la bdd
                dict_desc_aleas = self.bdd.recup_donnees(['description_alea'], 'c_phenomenes.zq', unique='description_alea')
                list_desc_aleas = sorted([res['description_alea'] for res in dict_desc_aleas])

                # Création d'une boîte de dialogue "container"
                container = QtWidgets.QInputDialog()
                container.setWindowTitle("Import de l'aléa")
                container.setLabelText(None)
                container.show()
                container.findChild(QLineEdit).hide()    # On cache la QLineEdit par défaut

                # Contenu de la boîte de dialogue
                label_terr = QtWidgets.QLabel("Choisissez votre territoire")
                cb_terr = QtWidgets.QComboBox()
                cb_terr.setEditable(False)
                cb_terr.addItems(list_terr)
                cb_terr.setCurrentIndex(list_terr.index(self.modele_terr_actif.terr))
                label_type_alea = QtWidgets.QLabel("Choisissez votre type d'aléa ou saisissez-en un")
                cb_type_alea = QtWidgets.QComboBox()
                cb_type_alea.setEditable(True)
                cb_type_alea.addItems(list_type_aleas)
                label_occurrence = QtWidgets.QLabel("Choisissez votre occurrence")
                cb_occurrence = QtWidgets.QComboBox()
                cb_occurrence.setEditable(True)
                cb_occurrence.addItems(list_occ)
                label_code_occurrence = QtWidgets.QLabel("Choisissez votre code occurrence")
                cb_code_occurrence = QtWidgets.QComboBox()
                cb_code_occurrence.setEditable(True)
                cb_code_occurrence.addItems(list_code_occ)
                label_description = QtWidgets.QLabel("Saisissez une description pour l'aléa importé")
                cb_description = QtWidgets.QComboBox()
                cb_description.setEditable(True)
                cb_description.addItems(list_desc_aleas)

                # Ajout des widgets dans le container
                container.layout().insertWidget(1, label_terr)
                container.layout().insertWidget(2, cb_terr)
                container.layout().insertWidget(3, label_type_alea)
                container.layout().insertWidget(4, cb_type_alea)
                container.layout().insertWidget(5, label_occurrence)
                container.layout().insertWidget(6, cb_occurrence)
                container.layout().insertWidget(7, label_code_occurrence)
                container.layout().insertWidget(8, cb_code_occurrence)
                container.layout().insertWidget(9, label_description)
                container.layout().insertWidget(10, cb_description)

                if container.exec_() == QtWidgets.QDialog.Accepted:
                    # Récupération des valeurs entrées par l'utilisateur
                    input_terr = cb_terr.currentText()
                    input_type_alea = cb_type_alea.currentText()
                    input_occurrence = cb_occurrence.currentText()
                    input_code_occurrence = cb_code_occurrence.currentText()
                    input_description = cb_description.currentText()

                    # Création d'un layer virtuel de même structure que 'zq'
                    vlayer= QgsVectorLayer(f"MultiPolygon?crs={reallayer.crs().authid()}","alea_virtuel","memory")
                    liste_champs_zq = self.bdd.get_liste_champs('zq')
                    l_fields = QgsFields()
                    [l_fields.append(f) for f in liste_champs_zq]

                    # Ajout des entités dans le vlayer du fichier géographique choisi par l'utilisateur
                    features = []
                    for feat in reallayer.getFeatures():
                        feature = QgsFeature()
                        feature.setFields(l_fields)
                        feature.setGeometry(feat.geometry())
                        for f in liste_champs_zq:
                            if f.name() != 'id' and f.name() in feat.fields().names():
                                feature[f.name()] = feat[f.name()]
                        feature['occurrence'] = input_occurrence
                        feature['code_occurrence'] = input_code_occurrence
                        feature['territoire'] = input_terr
                        feature['type_alea'] = input_type_alea
                        feature['description_alea'] = input_description

                        features.append(feature)

                    vlayer.startEditing()
                    vlayer.dataProvider().addAttributes(liste_champs_zq)
                    vlayer.updateFields()
                    vlayer.dataProvider().addFeatures(features)
                    vlayer.commitChanges()

                    # Calcul de l'aléa (dissolve), sauvegarde en base dans zq des nouvelles entités et définition du nouvel aléa en mémoire
                    self.modele_terr_actif.create_alea(input_terr, input_type_alea, input_code_occurrence, input_description, vlayer)
                    self.modele_terr_actif.def_alea()
                    self.update_alea()

                    QgsMessageLog.logMessage(f"Import de l'aléa terminé", "AgiRisk", level = Qgis.Info)
                    QMessageBox.information(self, "Ajout d'une couche d'aléa", f"Import de l'aléa terminé avec succès.")

                    del(vlayer)



    def choix_territoire(self):
        '''Méthode appelée lors de la sélection d'un territoire d'étude présent dans la bdd. Affiche le territoire dans le canvas QGIS et la minimap. Liste les aléas du territoire sélectionné.'''
        nom_terr = self.cbox_terr_etude.currentText()
        if self.cbox_terr_etude.currentText() not in self.modeles_terr.keys():
            self.modeles_terr[nom_terr] = ModeleTerritorial(self, nom_terr)

        # Mise à jour de la couche territoire d'étude du modèle territorial
        if not self.modeles_terr[nom_terr].couche_terr:
            QgsMessageLog.logMessage("Territoire non défini", "AgiRisk", level = Qgis.Warning)
            del self.modeles_terr[nom_terr]
        else:
            self.modele_terr_actif = self.modeles_terr[nom_terr]
            # On ne connecte le signal de changement dans le canvas que si le modèle territorial est défini
            if not self.modele_terr_est_defini:
                self.canvas.scaleChanged.connect(self.maj_zoom)
                self.modele_terr_est_defini = True
            # Il faut rendre invisibles les widgets liés aux autre territoires éventuellement en mémoire
            for terr in self.modeles_terr.keys():
                if nom_terr != terr:
                    self.modeles_terr[terr].rendre_invisible()

            self.update_alea()

            # Chargement du territoire dans la minimap & le canvas
            liste_couches = self.modele_terr_actif.liste_couches() + [self.ressources.basemaps['osm']]
            self.load_layer_in_minimap(liste_couches)
            self.echelle_prec = int(self.canvas.scale())
            self.maj_zoom(nveau_chargement=True)

            # Mise à jour des labels rappels dans les autres onglets
            self.lbl_te_modacalcul.setText(f"Territoire d'étude : {self.modele_terr_actif.terr}")

            self.mettre_a_jour_dispo_rep_carto_en_base()

            # Mise à jour de l'interface graphique pour désactiver les boutons indicateurs / diagnostic / actions
            self.etape_avancement = "choix_territoire"
            self.maj_etape_avancement()
            self.affiche_page("terr_etude")
            self.init_indicateurs_json()
            self.maj_statut_calculs_en_base()
            self.cbox_couche_alea.setEnabled(True)
            self.cbox_type_alea.setEnabled(True)

        return None


    def maj_statut_calculs_en_base(self):
        '''Méthode qui permet de changer l'apparence des boutons de lancement des calculs de variables, indicateurs et représentations cartographiques
        en fonction de l'état de la base
        TODO : changer la structure de la base pour y inclure un état de calcul des différentes variables, indicateurs et représentations cartographiques'''

        variables_calculees, indicateurs_calcules, rep_carto_calculees = self.bdd.recup_statut_calculs(self.modele_terr_actif.terr)

        self.pb_var_all.setStyleSheet(self.ressources.css_bt_calcul_indic['calcule']) if variables_calculees else self.pb_var_all.setStyleSheet(self.ressources.css_bt_calcul_indic['non_lance'])
        self.pb_var_all.setText('Calculs déjà effectués') if variables_calculees else self.pb_var_all.setText('Lancer le calcul des :\n- variables\n- indicateurs\n- représentations\ncartographiques')
        self.pb_var_all.setEnabled(not variables_calculees)


    def mettre_a_jour_dispo_rep_carto_en_base(self):
        ''' Met à jour la couleurs des indicateurs selon leur disponibilité en base ou non, dans l'arborescence des indicateurs de l'onglet choix_indicateurs'''

        # On lance la mise à jour de l'arborescence des indicateurs
        self.liste_rep_carto_dispos_en_base = self.bdd.liste_indicateurs()
        self.liste_rep_carto_dispos_en_base_par_terr = {}

        # Mise à jour de l'arborescence en fonction de la disponibilité en base des indicateurs
        for indic in self.liste_rep_carto_dispos_en_base:
            # Le code de l'indicateur est avant '_rc_' et le nom du territoire est après '_rc_'
            code_indic = indic.split('_rc_')[0]
            territoire = indic.split('_rc_')[1]

            if territoire not in self.liste_rep_carto_dispos_en_base_par_terr.keys():
                self.liste_rep_carto_dispos_en_base_par_terr[territoire] = []
            if code_indic not in self.liste_rep_carto_dispos_en_base_par_terr[territoire]:
                self.liste_rep_carto_dispos_en_base_par_terr[territoire].append(code_indic)
        for pt_vue in self.ressources.liste_pts_vue:
            for indic, widget_indic in self.modele_terr_actif.arbo_indicateurs.widgets_indicateurs[pt_vue].items():
                existe_en_base = indic in self.liste_rep_carto_dispos_en_base_par_terr[self.modele_terr_actif.terr.replace('\'', '_').replace(' - ', '_').replace('-', '_').replace(' / ', '_').replace('/', '_').replace(' ', '_').lower()] if self.modele_terr_actif.terr.replace('\'', '_').replace(' - ', '_').replace('-', '_').replace(' / ', '_').replace('/', '_').replace(' ', '_').lower() in self.liste_rep_carto_dispos_en_base_par_terr.keys() else False
                widget_indic.bouton.change_dispo(existe_en_base)

        # Mise à jour de l'affichage de l'arborescence en fonction du point de vue sélectionné
        self.changer_pt_vue()


    def update_alea(self):
        '''Met à jour les comboxbox choix_alea et type_alea'''

        # Mise à jour de la comboBox des couches aléas
        self.cbox_type_alea.currentIndexChanged.disconnect()
        self.cbox_couche_alea.currentIndexChanged.disconnect()
        self.cbox_couche_alea.clear()
        self.cbox_type_alea.clear()
        list_type_aleas = self.bdd.recup_donnees(['type_alea'], 'c_phenomenes.zx', where="territoire='" + self.modele_terr_actif.terr.replace("'", "''") + "'", unique='type_alea')
        if list_type_aleas:
            for type_alea in list_type_aleas:
                self.cbox_type_alea.addItem(type_alea['type_alea'])
        else:
            self.cbox_type_alea.addItem("Sélectionnez un territoire d'étude")
        self.cbox_type_alea.setCurrentIndex(-1)
        self.cbox_type_alea.currentIndexChanged.connect(self.choix_type_alea)
        self.cbox_couche_alea.setCurrentIndex(-1)
        self.cbox_couche_alea.currentIndexChanged.connect(self.choix_couche_alea)

        return None


    def load_layer_in_canvas(self, layers):
        '''
        Charge les couches passées en paramètre dans le canvas QGIS
        TODO : Créer l'arborescence correspondant au point de vue dans le gestionnaire de couches
        TODO : Insérer les couches à la bonne place dans l'arborescence
        TODO : Catcher les changements de niveau de zoom dans le canvas et recharger le bon niveau d'aggrégation de chaque couche
        '''
        # On vérifie que le groupe "AgiRisk" existe et on le crée sinon
        root = QgsProject.instance().layerTreeRoot()
        self.layer_tree[self.modele_terr_actif.terr] = root.findGroup(f"AgiRisk - {self.modele_terr_actif.terr}")
        if not self.layer_tree[self.modele_terr_actif.terr]:
            self.layer_tree[self.modele_terr_actif.terr] = root.insertGroup(0, f"AgiRisk - {self.modele_terr_actif.terr}")

        # On supprime toutes les couches déjà présentes dans le groupe
        self.layer_tree[self.modele_terr_actif.terr].removeAllChildren()

        # On masque tous les autres groupes "AgiRisk" (autres territoires précédemment chargés)
        for terr in self.layer_tree.keys():
            self.layer_tree[terr].setExpanded(False)
            self.layer_tree[terr].setItemVisibilityChecked(False)
        self.layer_tree[self.modele_terr_actif.terr].setExpanded(True)
        self.layer_tree[self.modele_terr_actif.terr].setItemVisibilityChecked(True)

        # On charge la liste des couches fournies en paramètre
        ids = []
        for i, layer in enumerate(layers):
            self.layer_tree[self.modele_terr_actif.terr].insertLayer(i, layer)
            if i > 0 and i < 4:
                ids.append(layer.id())
        for id in ids:
            couche = self.layer_tree[self.modele_terr_actif.terr].findLayer(id)
            if couche:
                fichier_style = os.path.join(os.path.dirname(__file__), 'ressources', 'styles_affichage', 'style_zx.qml')
                couche.layer().loadNamedStyle(fichier_style)

        # On zoome sur le territoire d'étude
        self.canvas.setExtent(layers[0].extent())
        self.canvas.refresh()


    def load_layer_in_minimap(self, layers, extent=None):
        minimap_canvas = self.carte_territoire
        minimap_canvas.setDestinationCrs(QgsCoordinateReferenceSystem('EPSG:2154'))
        minimap_canvas.setLayers(layers)
        if extent:
            minimap_canvas.setExtent(extent)
        else:
            minimap_canvas.setExtent(layers[0].extent())
        minimap_canvas.refresh()

        return None


    def choix_couche_alea(self):
        '''Lorsque l'utilisateur sélectionne une couche aléa déjà existante, mise à jour du modèle territorial et
        chargement de la couche dans le canvas QGIS et dans la minimap.
        '''
        # Mise à jour du modèle territorial
        if self.cbox_couche_alea.currentText() in ["", "Sélectionnez un territoire d'étude"]:
            self.modele_terr_actif.def_occurrence(None)
            self.modele_terr_actif.def_alea()
        else:
            self.modele_terr_actif.def_occurrence(self.cbox_couche_alea.currentText())
            self.modele_terr_actif.def_alea()

            # Chargement de la couche aléa dans la minimap & le canvas
            liste_couches = self.modele_terr_actif.liste_couches() + [self.ressources.basemaps['osm']]
            self.load_layer_in_minimap(liste_couches)
            self.echelle_prec = int(self.canvas.scale())
            self.maj_zoom(nveau_chargement=True)


        # Mise à jour des labels rappels dans les autres onglets
        self.lbl_occ_modacalcul.setText(f"Occurrence : {self.modele_terr_actif.occurrence}")

        # Mise à jour de l'interface graphique pour désactiver les boutons postérieurs à l'étape actuelle
        self.etape_avancement = "diagnostic"
        self.maj_etape_avancement()
        self.affiche_page("terr_etude")


    def choix_type_alea(self):
        '''
        Méthode appelée lorsque l'utilisateur change de type d'aléa : la comboBox Aléa est mise à jour
        '''
        # Mise à jour du type d'aléa dans le modèle territorial
        if self.cbox_type_alea.currentText() == "Sélectionnez un territoire d'étude":
            self.modele_terr_actif.def_type_alea("")
        else:
            self.modele_terr_actif.def_type_alea(self.cbox_type_alea.currentText())

        # On déconnecte le signal de la comboBox choix_couche_alea le temps de l'actualiser
        self.cbox_couche_alea.currentIndexChanged.disconnect(self.choix_couche_alea)
        self.cbox_couche_alea.clear()
        if self.cbox_type_alea.currentText() in ["", "Sélectionnez un territoire d'étude"]:
            clause_type_alea = ""
            self.modele_terr_actif.def_type_alea(None)
        else:
            clause_type_alea = " AND type_alea='" + self.cbox_type_alea.currentText().replace("'", "''") + "'"
            self.modele_terr_actif.def_type_alea(self.cbox_type_alea.currentText())
        dict_liste_aleas = self.bdd.recup_donnees(['territoire', 'code_occurrence'], 'c_phenomenes.zx', where="territoire='" + self.modele_terr_actif.terr.replace("'", "''") + "'" + clause_type_alea, unique='territoire, code_occurrence')
        if dict_liste_aleas:
            list_aleas = sorted([alea['code_occurrence'] for alea in dict_liste_aleas])
            self.cbox_couche_alea.addItems(list_aleas)
        # On reconnecte le signal de la comboBox Aléa en obligeant l'utilisateur à venir sélectionner une couche aléa
        self.cbox_couche_alea.setCurrentIndex(-1)
        self.cbox_couche_alea.currentIndexChanged.connect(self.choix_couche_alea)

        # Mise à jour des labels rappels dans les autres onglets
        self.lbl_typealea_modacalcul.setText(f"Aléa : {self.modele_terr_actif.type_alea}")


    ##########################################################################################################
    # Section Choix des indicateurs
    ##########################################################################################################
    def changer_pt_vue(self):
        '''
        Lorsque l'utilisateur valide le choix d'un des points de vue proposés (par défaut : rb_pt_de_vue_sngri est checked),
        on déclenche l'affichage dans tw_arborescence du premier niveau du point de vue sélectionné par l'utilisateur (3 objectifs SNGRI ou
        grandes catégories Population/Economie/... pour point de vue porteur de PAPI)
        '''

        for pt_vue in self.pts_vue.keys():
            if self.pts_vue[pt_vue]['w_arborescence'].isChecked():
                self.pt_vue_actif = pt_vue
                self.modele_terr_actif.arbo_indicateurs.active_arborescence(self.pt_vue_actif)
                self.echelle_prec = int(self.canvas.scale())
                self.maj_zoom(nveau_chargement=True)
        index_pts_vues = {'SNGRI': 0, 'Aménagement': 1, 'Crise': 2}
        self.dashboards.setCurrentIndex(index_pts_vues[self.pt_vue_actif])

        # Modification des activation des boutons d'onglet pour revenir à l'étape diagnostic
        self.etape_avancement = "diagnostic"
        self.maj_etape_avancement()
        self.affiche_page("choix_indic")
    

    def lancer_calculs(self):
        '''Méthode appelée lorsque l'utilisateur clique sur le bouton "Calculer les variables" de l'onglet Modalités de calcul'''
        # On affiche d'abord un avertissement expliquant que le calcul peut être long. Si l'utilisateur choisit de poursuivre, on lance le calcul
        msgBox = QMessageBox()
        msgBox.setWindowTitle("Lancement du calcul des variables")
        msgBox.setText("Le calcul des variables peut être long (~35 min sur un territoire à dominante urbaine [~50 communes / ~800 km²]). \nVoulez-vous poursuivre ?")
        msgBox.setStandardButtons(QMessageBox.Yes | QMessageBox.No)
        msgBox.setDefaultButton(QMessageBox.No)
        retour = msgBox.exec_()
        if retour == QMessageBox.No:
            return None
        
        # On affiche le retour d'exécution dans un nouvelle fenêtre, à laquelle est ajoutée un QTextEdit
        self.fenetre_log = QDialog()
        self.fenetre_log.setWindowTitle("Log d'exécution --> Enregistré dans le dossier parametres_locaux/logs/")
        self.fenetre_log.resize(800, 600)
        self.fenetre_log.setLayout(QVBoxLayout())
        self.textedit_log = QTextEdit("LANCEMENT DU CALCUL DE L'ENSEMBLE DES VARIABLES, INDICATEURS et REPRESENTATIONS CARTOGRAPHIQUES")
        self.fenetre_log.layout().addWidget(self.textedit_log)
        self.fenetre_log.show()
        log_exec = self.modele_terr_actif.lancement_calcul_bdd("pt_vue", '__var_all')
        if log_exec:
            for ligne in log_exec:
                log = ligne.split("\n")[0].replace("NOTICE:  ", "")
                self.textedit_log.append(f"{log}")
            self.fenetre_log.setFocus()

            self.lancer_calcul_indicateurs()

    
    def lancer_calcul_indicateurs(self):
        '''Méthode appelée lorsque l'utilisateur clique sur le bouton "Calculer les indicateurs" de l'onglet Modalités de calcul'''
        
        log_exec = self.modele_terr_actif.lancement_calcul_bdd("pt_vue", '__indic_all')
        if log_exec:
            # On affiche le retour d'exécution dans un nouvelle fenêtre, à laquelle est ajoutée un QTextEdit
            for ligne in log_exec:
                log = ligne.split("\n")[0].replace("NOTICE:  ", "")
                self.textedit_log.append(f"{log}")
            self.fenetre_log.setFocus()

            self.lancer_calcul_rep_carto()



    def lancer_calcul_rep_carto(self):
        '''Méthode appelée lorsque l'utilisateur clique sur le bouton "Calculer les représentations cartographiques" de l'onglet Modalités de calcul'''
        
        log_exec = self.modele_terr_actif.lancement_calcul_bdd("pt_vue", '__indic_rc_all')
        if log_exec:
            # On affiche le retour d'exécution dans un nouvelle fenêtre, à laquelle est ajoutée un QTextEdit
            for ligne in log_exec:
                log = ligne.split("\n")[0].replace("NOTICE:  ", "")
                self.textedit_log.append(f"{log}")
            self.fenetre_log.setFocus()

            # Une fois le calcul effectué, on désactive le bouton et on change l'affichage pour qu'il soit en vert
            self.pb_var_all.setStyleSheet(self.ressources.css_bt_calcul_indic['calcule'])
            self.pb_var_all.setText('Calculs effectués')
            self.pb_var_all.setEnabled(False)

            # On lance la mise à jour de l'arborescence des indicateurs
            self.mettre_a_jour_dispo_rep_carto_en_base()
    

    ##########################################################################################################
    # Section Modalités de calcul
    ##########################################################################################################
    def charger_indicateurs_selectionnes(self):
        '''Cette méthode permet de charger dans le Canvas les indicateurs sélectionnés sur le territoire sélectionné
        méthode appelée par le bouton "Charger les indicateurs sélectionnés" de l'onglet Modalités de calcul
        méthode remplacée par charger_diagnostic()
        '''

        for code_indic in self.indicateurs.keys():
            if 'widget_base' in self.indicateurs[code_indic].keys():
                if self.indicateurs[code_indic]['widget_base'].checkState() == 2:
                    indic = code_indic.split('_rc_')[0]
                    self.modele_terr_actif.charger_couche_indic(indic)
        # liste_couches = self.modele_terr_actif.liste_couches() + [self.ressources.basemaps['osm']]
        # self.load_layer_in_canvas(liste_couches)
        self.echelle_prec = int(self.canvas.scale())
        self.maj_zoom(nveau_chargement=True)
        pass


    def calcul_expert(self):
        '''Cette méthode permet de lancer les fonctions de calcul sélectionnées par l'utilisateur'''

        self.modele_terr_actif.lancement_calcul_bdd("pt_vue", '__var_all')
        self.modele_terr_actif.lancement_calcul_bdd("pt_vue", '__indic_all')
        self.modele_terr_actif.lancement_calcul_bdd("pt_vue", '__indic_rc_all')


    def maj_millesime(self):
        '''Méthode conservée uniquement pour historique, non active actuellement'''
        for couche, millesime in self.millesimes.items():
            self.modele_terr_actif.choix_millesime(couche, millesime['widget'].currentText())


    ##########################################################################################################
    # Section Diagnostic
    ##########################################################################################################
    def charger_diagnostic(self):
        '''Cette méthode permet de charger dans le Canvas les indicateurs sélectionnés sur le territoire sélectionné
        puis de charger le dashboard associé'''

        # On parcourt l'arborescence des indicateurs affichée à l'utilisateur pour déterminer quels indicateurs sont sélectionnés
        for code_indic, widget_indic in self.modele_terr_actif.arbo_indicateurs.widgets_indicateurs[self.pt_vue_actif].items():
            if widget_indic.bouton.retenu == True:
                self.modele_terr_actif.charger_couche_indic(code_indic.replace("/","_").lower())

        # Calcul des regroupements géographiques pour permettre le chargement des dashboards associé
        self.modele_terr_actif.calcul_regroupements()

        # Une fois le dashboard chargé, on définit la comboBox des niveaux d'échelles de synthèse pour déclencher la mise à jour du dashboard
        echelle_par_defaut = {'TRI Verdun': 2, 'TRI Noirmoutier SJDM': 0, 'Jura': 2}
        self.cbox_niv_synthese.setCurrentIndex(echelle_par_defaut[self.modele_terr_actif.terr] if self.modele_terr_actif.terr in echelle_par_defaut.keys() else 2)
        self.cbox_niv_synthese.currentIndexChanged.emit(self.cbox_niv_synthese.currentIndex())
        self.cbox_secteur_etude.setCurrentIndex(0)
        self.cbox_secteur_etude.currentIndexChanged.emit(self.cbox_secteur_etude.currentIndex())

        # Une fois le dashboard chargé, on permet à l'utilisateur d'ouvrir l'onglet actions
        self.etape_avancement = "choix_actions"
        self.maj_etape_avancement()
        self.affiche_page("diagnostic")


    def maj_echelle_synthese(self):
        '''Méthode appelée lors de la sélection de l'échelle via la comboBox des niveaux de synthèse'''
        self.echelle = self.ressources.niv_zoom_code[self.cbox_niv_synthese.currentText()]
        self.modele_terr_actif.dashboard.maj_echelle_synthese()


    def maj_secteur_etude(self):
        self.modele_terr_actif.dashboard.maj_secteur_etude()


    ##########################################################################################################
    # Section Diagnostic
    ##########################################################################################################
    def charger_onglet_actions(self):
        '''Mise à jour de l'onglet actions en fonction des indicateurs retenus'''
        self.arbo_actions.afficher_onglet()


    ##########################################################################################################
    # Section Interface graphique QGis
    ##########################################################################################################
    def maj_zoom(self, echelle_canvas=0, nveau_chargement=False):
        ''' Cette méthode est appelée lors du changement de zoom dans la carte
        ou bien lors d'un des changements suivants initiés par l'utilisateur :
        - Chargement d'un nouveau territoire
        - Chargement d'une nouvelle couche d'aléa
        - Chargement d'indicateurs
        - Changement de point de vue
        TODO : recoder plus proprement cette méthode car nveau_chargement contient la valeur d'échelle lorsque maj_zoom est appelée par le signal zoomLevelChanged'''

        # On détermine d'abord si le niveau de zoom a suffisamment changé pour changer les couches affichées
        classes_zoom = self.ressources.classes_zoom
        _, niv_zoom = chgt_classe_zoom(classes_zoom, int(self.canvas.scale()), int(self.canvas.scale()))
        if not nveau_chargement == True:
            zoom_change, niv_zoom = chgt_classe_zoom(classes_zoom, self.echelle_prec, int(self.canvas.scale()))
        self.echelle_prec = int(self.canvas.scale())
        if nveau_chargement == True or zoom_change:
            # Si le territoire n'a pas encore été défini, on ne fait rien
            if self.modele_terr_actif.terr is None:
                return

            # On vérifie que le groupe "AgiRisk" existe et on le crée sinon
            root = QgsProject.instance().layerTreeRoot()
            self.layer_tree[self.modele_terr_actif.terr] = root.findGroup(f"AgiRisk - {self.modele_terr_actif.terr}")
            if not self.layer_tree[self.modele_terr_actif.terr]:
                self.layer_tree[self.modele_terr_actif.terr] = root.insertGroup(0, f"AgiRisk - {self.modele_terr_actif.terr}")

            # On déplie le groupe du territoire actif et on cache les autres
            for terr in self.layer_tree.keys():
                self.layer_tree[terr].setExpanded(False)
                self.layer_tree[terr].setItemVisibilityChecked(False)
            self.layer_tree[self.modele_terr_actif.terr].setExpanded(True)
            self.layer_tree[self.modele_terr_actif.terr].setItemVisibilityChecked(True)

            # On supprime toutes les couches déjà présentes dans le groupe
            self.layer_tree[self.modele_terr_actif.terr].removeAllChildren()

            # On charge la liste des couches du modèle territorial
            dict_couches_a_afficher = self.modele_terr_actif.couches_a_afficher(niv_zoom)
            self.affiche_recurs(self.layer_tree[self.modele_terr_actif.terr], dict_couches_a_afficher)
            extent = self.modele_terr_actif.couche_terr.extent()
            liste_nom_couches = [layer.name() for layer in self.layer_tree[self.modele_terr_actif.terr].checkedLayers()]

            # On zoome sur le territoire d'étude
            if nveau_chargement == True:
                self.canvas.setExtent(extent) if extent is not None else None
            self.canvas.refresh()


    def affiche_recurs(self, groupe_parent, liste_couches):
        ''' Affichage récursif des couches récupérées dans le modèle territorial
        '''
        for couche_style in liste_couches:
            if couche_style['type'] == 'groupe':
                groupe = groupe_parent.addGroup(couche_style['nom_groupe'])
                groupe.visibilityChanged.connect(partial(self.maj_visibilite, groupe.name(), 'groupe'))
                groupe.setItemVisibilityChecked(couche_style['visible'] if 'visible' in couche_style.keys() else True)
                if 'legende_groupe' in couche_style.keys():
                    groupe.setName(couche_style['legende_groupe'][0].upper() + couche_style['legende_groupe'][1:])
                self.affiche_recurs(groupe, couche_style['enfants'])
            elif couche_style['type'] == 'couche':
                if 'layer' in couche_style.keys():
                    # On ajoute la couche dans le groupe parent
                    layer = groupe_parent.addLayer(couche_style['layer'])
                    layer.visibilityChanged.connect(partial(self.maj_visibilite, layer.layerId(), 'couche'))
                    layer.setItemVisibilityChecked(couche_style['visible'])
                    layer.setExpanded(couche_style['visible'])
                    if 'nom_couche' in couche_style.keys():
                        layer.setName(couche_style['nom_couche'][0].upper() + couche_style['nom_couche'][1:])
                    # TODO : ajouter une key 'expanded' dans le modèle pour conserver la persistence du expanded en dehors de l'attribut visible
                    # if 'expanded' in couche_style.keys():
                    #     layer.setExpanded(couche_style['expanded'])
            else:
                QgsMessageLog.logMessage(f"Type de couche inconnu : {couche_style['type']}", 'AgiRisk', Qgis.Warning)


    def maj_visibilite(self, name_or_id, type_couche):
        '''Cette méthode gère la mise à jour de la visibilité des couches du canvas en fonction des données du modèle territorial'''

        item = self.layer_tree[self.modele_terr_actif.terr].findGroup(name_or_id) if type_couche == 'groupe' else self.layer_tree[self.modele_terr_actif.terr].findLayer(name_or_id)
        name = name_or_id if type_couche == 'groupe' else item.layer().name()

        if type_couche == 'couche':
            if item is not None:
                self.modele_terr_actif.change_visibilite_couches(name, item.isVisible())
            else:
                QgsMessageLog.logMessage(f"Item {name} non trouvé - id = {name_or_id}", 'AgiRisk', Qgis.Warning)
        elif type_couche == 'groupe':
            # TODO : gérer la visibilité de toutes les couches du groupe
            pass
        else:
            QgsMessageLog.logMessage(f"NON DETECTE COMME COUCHE - Il s'agit de l'item : {name} - id = {name_or_id}", 'AgiRisk', Qgis.Info)

